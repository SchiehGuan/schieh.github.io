{"pages":[{"title":"about me","text":"witness me","link":"/about/index.html"}],"posts":[{"title":"Composer-入门基础","text":"一、依赖管理依赖关系项目目录下创建composer.json文件，作用：描述项目的依赖关系。 12345{ \"require\":{ \"monolog/monolog\":\"1.2.*\" }} 系统要求运行Composer需要PHP 5.3.2+以上版本，直接从包来源进行安装，包括git、svn、hg等，取决于包所使用的版本管理系统。 二、安装下载 Composer 的可执行文件123456789101112131415// 局部安装curl -sS https://getcomposer.org/installer | php// 安装失败可使用pho下载安装器php -r &quot;readfile(&apos;https://getcomposer.org/installer&apos;);&quot; | php// 指定安装目录 --install-dircurl -sS https://getcomposer.org/installer | php -- --install-dir=bin// 全局安装，mv可能存在权限不足，可sudo切换rootcurl -sS https://getcomposer.org/installer | phpmv composer.phar /usr/local/bin/composer// 检查Composer是否正常工作,将会返回一个可执行命令列表php composer.phar macos/windows/on OSX via homebrew，参考https://docs.phpcomposer.com/00-intro.html 三、使用Composercomposer.json - 包管理文件composer.json：该文件包含项目的依赖和其他的一些元数据。 require12345{ \"require\": { \"monolog/monolog\": \"1.0.*\" }} require：描述依赖包的映射，告诉Composer你的项目需要依赖哪些包。 包名称为避免名称冲突，包命名方式为：groupName/projectName 包版本版本约束 名称 实例 描述 确切的版本号 1.0.2 你可以指定包的确切版本。 范围 &gt;=1.0 &gt;=1.0,&lt;2.0 &gt;=1.0,&lt;1.1|&gt;=1.2 通过使用比较操作符可以指定有效的版本范围。 有效的运算符：&gt;、&gt;=、&lt;、&lt;=、!=。 你可以定义多个范围，用逗号隔开，这将被视为一个逻辑AND处理。一个管道符号|将作为逻辑OR处理。 AND 的优先级高于 OR。 通配符 1.0.* 你可以使用通配符*来指定一种模式。1.0.*与&gt;=1.0,&lt;1.1是等效的。 赋值运算符 ~1.2 这对于遵循语义化版本号的项目非常有用。~1.2相当于&gt;=1.2,&lt;2.0。想要了解更多，请阅读下一小节。 下一个重要版本 ~ 最好用例子来解释： ~1.2 相当于 &gt;=1.2,&lt;2.0，而 ~1.2.3 相当于 &gt;=1.2.3,&lt;1.3。正如你所看到的这对于遵循 语义化版本号 的项目最有用。一个常见的用法是标记你所依赖的最低版本，像 ~1.2 （允许1.2以上的任何版本，但不包括2.0）。由于理论上直到2.0应该都没有向后兼容性问题，所以效果很好。你还会看到它的另一种用法，使用 ~ 指定最低版本，但允许版本号的最后一位数字上升。 安装依赖包根据composer.json定义进行依赖包安装。 1php composer.phar install install命令将会找到对应的依赖包版本，下载到vendor目录。 如果采用git管理项目，可能需要将vendor添加到.gitignore文件中 另外，install命令将创建一个composer.lock文件到项目目录中。 composer.lock - 锁文件install命令会优先检查composer.lock文件是否存在，存在则下载lock中指定版本(忽略composer.json文件中的定义)，这意味着，任何人建立项目都将下载完全相同的依赖。 如果需要更新，则需要使用update命令，将根据composer.json文件进行安装并更新composer.lock文件 1php composer.phar update 如果只想安装或更新一个依赖，可以白名单它们： 1php composer.phar update monolog/monolog [...] Packagistpackagist 是 Composer 的主要资源库。 一个 Composer 的库基本上是一个包的源：记录了可以得到包的地方。Packagist 的目标是成为大家使用库资源的中央存储平台。这意味着你可以 require 那里的任何包。 四、自动加载对于库的自动加载信息，Composer 生成了一个 vendor/autoload.php 文件。你可以简单的引入这个文件，你会得到一个免费的自动加载支持。 1require 'vendor/autoload.php'; 这使得你可以很容易的使用第三方代码。例如：如果你的项目依赖 monolog，你就可以像这样开始使用这个类库，并且他们将被自动加载。 1234$log = new Monolog\\Logger('name');$log-&gt;pushHandler(new Monolog\\Handler\\StreamHandler('app.log', Monolog\\Logger::WARNING));$log-&gt;addWarning('Foo'); 你可以在 composer.json 的 autoload 字段中增加自己的 autoloader。 12345{ \"autoload\": { \"psr-4\": {\"Acme\\\\\": \"src/\"} }} Composer 将注册一个 PSR-4 autoloader 到 Acme 命名空间。 你可以定义一个从命名空间到目录的映射。此时 src 会在你项目的根目录，与 vendor 文件夹同级。例如 src/Foo.php 文件应该包含 Acme\\Foo 类。 添加 autoload 字段后，你应该再次运行 install 命令来生成 vendor/autoload.php 文件。 引用这个文件也将返回 autoloader 的实例，你可以将包含调用的返回值存储在变量中，并添加更多的命名空间。这对于在一个测试套件中自动加载类文件是非常有用的，例如。 12$loader = require 'vendor/autoload.php';$loader-&gt;add('Acme\\\\Test\\\\', __DIR__); 除了 PSR-4 自动加载，classmap 也是支持的。这允许类被自动加载，即使不符合 PSR-0 规范。详细请查看 自动加载-参考。 注意： Composer 提供了自己的 autoloader。如果你不想使用它，你可以仅仅引入 vendor/composer/autoload_*.php 文件，它返回一个关联数组，你可以通过这个关联数组配置自己的 autoloader。 参考： Composer简介 Composer基本用法","link":"/2018/11/05/composer-入门基础/"},{"title":"Git用户名邮箱配置相关","text":"全局配置 12git config --global user.name \"username\"git config --global user.email \"email\" 局部项目设置不同配置 12git config user.name \"git's Name\"git config user.email \"git@xx.com\" 查看当前配置 12# git config --list查看当前配置, 在当前项目下面查看的配置是全局配置+当前项目的配置, 使用的时候会优先使用当前项目的配置git config --list git提交邮箱与github贡献图相关 为何通过git提交到github中，github overview贡献图没有更新？ 邮箱没有关联，就是github账号设置中的邮箱绑定，要与git提交的邮箱匹配，github才会认为是本人提交，才会记录到贡献图中，并且committer记录也会显示本人头像。 1234# 查看项目的配置git config --list# 设置github绑定的邮箱，局部和全局都行git config user.email \"email\" 更多参考：Why are my contributions not showing up on my profile?","link":"/2018/11/28/git用户名邮箱配置相关/"},{"title":"Git配置多账号","text":"背景​ 工作中经常会使用到git，但是如果需要同时使用个人账号和公司账号时，就需要配置git多账号切换。 配置1、配置key1 12345#新建SSH key：$ cd ~/.ssh # 切换到C:\\Users\\Administrator\\.ssh$ ssh-keygen -t rsa -C \"my@email.com\" # 新建工作的SSH key# 设置名称为id_rsa_meEnter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_me 2、配置key2 12345#新建SSH key：$ cd ~/.ssh # 切换到C:\\Users\\Administrator\\.ssh$ ssh-keygen -t rsa -C \"mywork@email.com\" # 新建工作的SSH key# 设置名称为id_rsa_workEnter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_work 3、新增key 12345678# 新增key1$ ssh-add ~/.ssh/id_rsa_me# 新增key2$ ssh-add ~/.ssh/id_rsa_work# 如果显示两个key，证明添加成功$ ssh-add -l# Could not open a connection to your authentication agent错误，需要重置，再次执行上面步骤添加$ ssh-agent bash 4、创建ssh的config文件 1234# 在~/.ssh目录下找到config文件，如果没有就创建$ touch config# 编辑config$ vim ./config 我的config配置如下： 1234567891011# workHost git@gitlab.com HostName git@gitlab.alibaba-inc.com User your_name IdentityFile C:/Users/xxx/.ssh/id_rsa_work# meHost git@github.com HostName git@github.com User your_name IdentityFile C:/Users/xxx/.ssh/id_rsa_me 5、将id_rsa对应的pub文件的key,添加到github账号的ssh中 6、测试 12$ ssh -T git@gitlab.alibaba-inc.comWelcome to GIT, 关世杰! 7、配合IDEA使用 IDEA设置：Version Control -&gt; Git -&gt; SSH executable: Native 该设置的大意是：选择Native则采用本地ssh配置，采用Built-in则采用idea提供的配置。","link":"/2018/11/14/git配置多账号/"},{"title":"Hexo搭建踩坑汇总","text":"1. table渲染问题 md的table中，如果内容需要使用到`|`，正常使用没问题，但是hexo渲染成HTML的时候，会很蛋疼的把`|`识别成`|来进行断句，这就导致排版错乱。 解决办法： 取巧方法：使用全角字符｜代替| 采用html方式+转义字符 1&lt;code&gt;&amp;#124;&lt;/code&gt; （不适用当前情况）还有两个单引号，处理个别情况，比如要显示单引号，可以采用双单引号括起来 1`` ctr+` ``","link":"/2018/11/26/hexo搭建踩坑汇总/"},{"title":"php远程debug配置","text":"一、背景​ 最近要开始PHP，从老大那里了解到目前PHP是部署到打包好的linux虚拟机上，而开发则在本机上开发，而DEBUG的话就采用var_dump()函数，这种DEBUG效率与个人能力成正相关，代码越熟悉，技术越精湛，定位就越准确，相反的话无从入手。因此难道PHP就没有像Java那样远程调试的功能吗，立马上IDEA搜索一番，果不其然idea支持php远程debug功能。 二、环境 idea 2017.2.3 php 5.3.10 本机开发环境 win10 虚拟机PHP部署环境 linux centos6 三、集成IDEA远程开发与DEBUG1. 安装XDebug1.1 下载xdebug 1wget http://xdebug.org/files/xdebug-2.2.7.tgz 1.2 解压 1tar zxvf xdebug-2.2.7.tgz 1.3 编译 1234cd xdebug-2.2.7phpize # 生成configure文件./configure --enable-xdebug # 配置make &amp;&amp; make install # 编译并生成 1.4 复制xdebug.so模块到php目录 123cd modules/mkdir /home/shangsen/app/xdebug/modulescp xdebug.so /home/shangsen/app/xdebug/modules 2. 配置php.ini2.1 找到php.ini目录 1find / -name &apos;php.ini&apos; # 如果不清楚php.ini在哪的话 2.2 配置php.ini 123456789101112131415[XDebug]zend_extension = /home/shangsen/app/xdebug/modules/xdebug.so; Debug Configxdebug.remote_enable = 1xdebug.remote_handler = \"dbgp\"xdebug.remote_host = \"127.0.0.1\"xdebug.remote_port = 8001xdebug.remote_log = \"/home/shangsen/app/php/xdebug.log\"; Profiler Configxdebug.profiler_enable = 1xdebug.profiler_enable_trigger = 1xdebug.profiler_output_dir = \"/tmp/xdebug\"xdebug.profiler_output_name = \"out.%t-%s\" 如果只是用于调试，那么只要加#Debug Config和后面的几行。如果调试客户端（如：PHPStorm IDE）和PHP不在同一电脑上，则需要把xdebug.remote_host配置成调试客户端的IP。 如果要PHP程序性能分析，则再加上# Profiler Config以及后面的配置。 配置完后重启PHP服务 1service php-fpm restart #没有服务的话重启机子吧 查看XDebug的所有配置。 3. 配置IDEA3.1 创建应用 3.2 设置本地与远程代码路径映射关系 3.3 启动远程debug服务 3.4 OK 参考： idea ： Creating a PHP Debug Server Configuration xdebug IDEA集成xdebug远程调试功能","link":"/2018/11/07/php远程debug配置/"},{"title":"URL空格编码变加号(+)问题","text":"URL空格编码问题1234import java.net.URLEncoder;import java.nio.charset.StandardCharsetsString urlEncode = URLEncoder.encode(url, StandardCharsets.UTF_8.toString()); ​ 上面这段代码作用是将www.xxx.com?a=你好编码成www.xxx.com%3fa%3d%e4%bd%a0%e5%a5%bd，encode能将中文、特殊字符等编码成%xx的格式，以保证url的正常传递。 ​ 但是在encode遇到空格的时候，空格会被编码成+，导致在实际使用中出现问题，比如www.xxx.com?a=a b编码后会变成www.xxx.com?a=a+b。 空格的编码定义 HTML4编码定义 application/x-www-form-urlencodedThis is the default content type. Forms submitted with this content type must be encoded as follows: Control names and values are escaped. Space characters are replaced by `+\\’, and then reserved characters are escaped as described in [RFC1738], section 2.2: Non-alphanumeric characters are replaced by `%HH\\’, a percent sign and two hexadecimal digits representing the ASCII code of the character. Line breaks are represented as “CR LF” pairs (i.e., `%0D%0A’). The control names/values are listed in the order they appear in the document. The name is separated from the value by `=\\’ and name/value pairs are separated from each other by `&amp;`. 在HTML4中，表单提交的数据，空格被编码成+。 RFC-3986编码定义 2.1 Percent-Encoding A percent-encoding mechanism is used to represent a data octet in a component when that octet’s corresponding character is outside the allowed set or is being used as a delimiter of, or within, the component. A percent-encoded octet is encoded as a character triplet, consisting of the percent character “%” followed by the two hexadecimal digits representing that octet’s numeric value. For example, “%20” is the percent-encoding for the binary octet “00100000” (ABNF: %x20), which in US-ASCII corresponds to the space character (SP). Section 2.4 describes when percent-encoding and decoding is applied. 在RFC-3986中，百分号编码规定了空格的编码对应为%20。 Java中的URL编码​ Java中常用的URL编码类有两个：一个是JDK自带的java.net.URLEncoder,另一个是Apache的org.apache.commons.codec.net.URLCodec。这两个类遵循的都是HTML4标准，即将空格编码成加号+,代码如下： 123456//输出：%E4%BD%A0+%E5%A5%BDSystem.out.println(java.net.URLEncoder.encode(&quot;你 好&quot;, &quot;utf-8&quot;));//输出：%E4%BD%A0+%E5%A5%BDURLCodec en = new URLCodec(&quot;utf-8&quot;);System.out.println(en.encode(&quot;你 好&quot;)); 其实要将HTML4的编码结果转换成RFC-3986编码，方法很简单： 1java.net.URLEncoder.encode(&quot;你 好&quot;, &quot;utf-8&quot;).replaceAll(&quot;\\\\+&quot;, &quot;%20&quot;); 另外Netty中有一个QueryStringEncoder类可以可以实现RFC-3986的URL编码，代码如下： 1234QueryStringEncoder encoder = new QueryStringEncoder(&quot;/&quot;);encoder.addParam(&quot;name&quot;, &quot;开源+中国 博客&quot;);//输出：/?name=%E5%BC%80%E6%BA%90%2B%E4%B8%AD%E5%9B%BD%20%E5%8D%9A%E5%AE%A2System.out.println(encoder.toUri()); URL编码使用建议 表单使用HTML4标准 在网页提交表单的时候，空格会被编码成+，服务端解析数据的时候，又会把+解码成空格。 链接URL使用RFC-3986标准 URL采用百分号编解码，即RFC-3986标准，将空格编码成%20。 参考: 空格URL编码的正确使用姿势","link":"/2018/12/11/url空格编码变加号-问题/"},{"title":"函数式编程","text":"前言最近准备开始学Spring5的WebFlux，涉及到响应式编程的概念，因此想在开始学习响应式编程之前，先把以前学的java8函数式编程的概念整理一下，何为函数式编程。 什么是函数(Function)函数属于数学的范畴，其定义为：y=f(x)，f被称作函数，x是函数的参数，y则是函数的值。 因此函数是将集合X的每个元素x与另一集合Y（可能是同一集合）的单个元素y相关联的过程或关系。 什么是纯函数(Pure Function) Its return value is the same for the same arguments (no variation with local static variables, non-local variables, mutable reference arguments or input streams from I/O devices). Its evaluation has no side effects) (no mutation of local static variables, non-local variables, mutable reference arguments or I/O streams). 引用透明（参数不变，返回值总是相同） 没有副作用（不影响外部变量） 只有满足上述两个条件才算Pure Function，下面给出正例反例： 123456789101112131415var num = 0;// 满足1，2function sum(a, b){ return a + b;}// 满足1，不满足2function sum(a, b){ num++; return a + b;}// 不满足1，不满足2function sum(a, b){ num++; return a + b + num;} 例子很简单，就用JS写吧，反而用java写会显得复杂，对于第一个，函数不受外部影响，第二个，函数不影响外部。 什么是函数式编程(Functional Programming)函数式编程，就是在尽可能满足上述两个条件的一种编程范式，编程上函数是一等公民，对程序没有副作用，引用透明。 命令式编程属于命令状态的更改，简单的例子就是赋值，而函数式编程属于数据关系的映射，下图采用lambda表达式来说明数据关系映射的过程。 除此以外，函数式编程还包含许多特性，比如：闭包（柯里化、反柯里化）、高阶函数、惰性计算、递归、函数节流、分时函数等。 柯里化（Currying） wiki：在计算机科学中，柯里化（Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 柯里化的简单实现： 12345678910111213// 正常求和var sum = function(x,y){ return x+y;}sum(1,2);//return 3// 实现柯里化函数var sum = function(x){ return function(y){ return x+y; }};sum(1)(2);//return 3 柯里化的优点：延迟计算、参数复用、动态生成函数。 参考： Function：https://en.wikipedia.org/wiki/Function Pure Function：https://en.wikipedia.org/wiki/Pure_function#Impure_functions Functional Programming：https://en.wikipedia.org/wiki/Functional_programming","link":"/2018/12/04/函数式编程/"},{"title":"linux部署gitlab","text":"前言之前在阿里云上买了个服务器，一直没怎么用，就想拿来搭个gitlab，方便用来管理自己一些文件同步，虽然也有oss或者google drive，但是git的版本控制功能，更方便管理文件的修改同步。 服务器配置：linux centos7、2G内存、40G存储 安装和配置必要的依赖12345sudo yum install -y curl policycoreutils-python openssh-serversudo systemctl enable sshdsudo systemctl start sshdsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 安装postfix（发送邮件通知功能） 123456#安装邮件服务器：Postfixsudo yum install postfix#加载Postfix服务sudo systemctl enable postfix#启动Postfix服务sudo systemctl start postfix 安装gitlab123456789#gitlab-ee企业版（跳过）# curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash#gitlab-ce社区版curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash# 企业版（跳过）#sudo EXTERNAL_URL=\"http://gitlab.example.com\" yum install -y gitlab-ee# 社区版：url修改自己的实际地址sudo EXTERNAL_URL=\"http://gitlab.example.com\" yum install -y gitlab-ce 启动gitlab1sudo gitlab-ctl reconfigure 设置root密码 打开浏览器，默认本机80端口，进入gitlab主页 初始化root账号的密码 登陆，默认账号root,以及上一步的密码 相关配置 修改nginx默认80端口，打开vim var/opt/gitlab/nginx/conf/gitlab-http.conf 123server { listen *:8001;} gitlab本身采用80端口,配置GitLab的URL，修改 vim /etc/gitlab/gitlab.rb 1external_url &apos;http://127.0.0.1:8001&apos; 每次重新配置，都需要执行sudo gitlab-ctl reconfigure 使之生效。 相关命令 启动：gitlab-ctl start|stop|status|restart 所有日志：gitlabctl tail nginx日志：gitlab-ctl tail nginx/gitlab_access.log 卸载gitlab 停止gitlab，执行sudo gitlab-ctl stop 卸载gitlab，执行sudo rpm -e gitlab-ce 查看gitlab进程，杀掉第一个守护进程kill -9 pid 删除gitlab文件，执行find / -name gitlab|xargs rm -rf删除所有包含gitlab的文件及目录，再执行gitlab-ctl uninstall删除自动在root下备份的配置文件。 遇到的坑一开始部署完gitlab，我那可怜的2G内存已经所剩无几了，然后在使用的过程中发现经常push失败，gitlab管理页面响应奇慢，想着可能是内存不够的问题，但实际不是！ 参考：阿里云云主机添加swap分区与swap性能优化 开启阿里云swap阿里当前的做法是： 不创建swap分区，由镜像决定 将vm.swappiness设定为0，即永不使用swap分区 启用swap分区，确实可以降低内存的使用压力，但并不是长久之计，如果云主机上运行的应用确实需要较高的内存，建议还是购买更多的内存。 启用swap分区 查看当前系统中是否已经启用swap分区，没有数据则没有开启 1cat /proc/swaps 如果没有启用swap分区功能，则新建一个专门的文件用于swap分区 1dd if=/dev/zero of=/data/swap bs=512 count=8388616 分区大小设置为4G，bs*count=4294971392(4G) /data/swap目录不存在的话，替换成/mnt/swap，下面所有涉及的/data/swap都替换 通过mkswap命令将上面新建出的文件做成swap分区 1mkswap /data/swap 查看内核参数vm.swappiness中的数值是否为0，如果为0则根据实际需要调整成30或者60 12cat /proc/sys/vm/swappinesssysctl -w vm.swappiness=60 注：若想永久修改，则编辑/etc/sysctl.conf文件 启用此交换分区的交换功能 12swapon /data/swapecho \"/data/swap swap swap defaults 0 0\" &gt;&gt; /etc/fstab 查看swap分区是否启动 1cat /proc/swaps 如何关闭swap分区？ 12swapoff /data/swapswapoff -a &gt; /dev/null","link":"/2018/12/05/linux部署gitlab/"},{"title":"Docker安装与命令","text":"前言从18年开始接触docker，之前linux安装那一套现在已经区分为CE、EE版本，安装上也与旧版有所不同，所以总结一下docker的安装与命令使用，方便自己使用。 Docker安装Centos7安装目前docker提供两个版本： 社区版(CE) 企业版(EE) CE版有两个更新渠道： Stable 每个季度为您提供可靠更新 Edge 每个月为您提供新功能 卸载旧版本 12345678910sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装yum相关依赖包 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加yum软件源 123# 使用国内源sudo yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo# 官方原始源https://download.docker.com/linux/centos/docker-ce.repo 安装docker 1234# 更新yum软件包索引sudo yum makecache fast# 安装docker-cesudo yum install docker-ce 启动docker 1sudo systemctl start docker 验证docker是否正确安装 1sudo docker run hello-world Docker常用命令容器生命周期管理命令：123456789101112131415161718192021222324252627282930313233343536373839# run：运行容器docker run [OPTIONS] IMAGES [COMMAND] [ARG..]-d 后台运行-i 交互模式运行-t 重新分配伪输入终端--name=\"name\" 设置容器名-e key=value 设置环境变量--env-file=[] 从指定文件读取环境变量-p 80:80 端口映射-m 500M 设置容器使用最大内存,默认不受限-v /a:/b 宿主与容器文件夹共享映射--privileged=true 容器拥有访问宿主机所有权限# start/stop/restart 启动/停止/重启容器docker start/stop/restart [OPTIONS] CONTAINER [CONTAINER...]docker start/stop/restart $(docker ps -aqf status=exited) 批量重启docker stop -t int 等待int秒后停止容器，默认延迟10秒后才真正停止容器# kill 强制终止容器的运行-s 发送指定系统信号，默认是`KILL`docker kill -s SIGINT# rm 删除容器-f 通过SIGKILL信号强制删除一个运行中的容器-l 移除容器间的网络连接，而非容器本身-v 删除与容器关联的卷docker rm -f CONTAINER# pause/unpause 暂停/恢复容器中所有的进程docker pause/unpause CONTAINER# create 创建一个新的容器但不启动它，同run命令操作docker create --name mysql mysql# exec 在运行的容器中执行命令-d 分离模式：在后台运行-i 保持STDIN打开-t 分配一个伪终端docker exec -it mysql /bin/bash 容器操作命令1234567891011121314151617181920212223242526272829303132333435363738394041# ps [OPTIONS] 列出容器-a 显示所有容器，包括停止的容器-f 根据条件过滤显示的内容--format 指定返回值的模板文件-l 显示最近创建的容器-n 列出最近创建的n个容器--no-trunc 不截断输出，原信息中的命令和id是被剪短的版本-q 静默模式，只显示容器编号-s 显示总的文件大小# inspect [OPTIONS] CONTAINER|IMAGE.. 获取容器/镜像的元数据-f 指定返回值的模板文件-s 显示总的文件大小--type 为指定类型返回json# top [OPTIONS] CONTAINER [ps OPTIONS] 容器运行时不一定有/bin/bash终端来交互执行top命令，而且不一定有top命令，可以使用docker top来实现查看container中正在运行的进程docker top mysql# 查看所有运行容器的进程信息for i in `docker ps |grep Up|awk '{print $1}'`;do echo \\ &amp;&amp;docker top $i;done # attach [OPTIONS] CONTAINER 连接到正在运行中的容器，和exec差不多，但是ctrl + d退出容器会让容器停止，正确退出是ctrl + p + q，还有共享屏幕的功能# events [OPTIONS] 获取实时事件，包括容器事件，镜像事件等-f 过滤事件--since 从指定的时间戳后显示所有事件--until 流水时间显示到指定的时间为止# logs [OPTIONS] CONTAINER 查看容器日志,可以配合grep过滤| grep hello -f 滚动日志--details 显示额外详细信息--tail=200 查看最后200行--since 显示某个时间后的日志，eg 2019-01-02T12:00:00--until 显示某个时间前的日志，同上-t 显示时间戳# wait [OPTIONS] CONTAINER... 阻塞运行直到容器停止，然后打印它的退出代码# export [OPTIONS] CONTAINER 将文件系统作为一个tar归档文件导出到STDOUT-o 将输入内容写入文件# port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]] 列出指定的容器的端口映射，或查找将PRIVATE_PORT NAT到面向公众的端口 容器rootfs命令12345678910111213# commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 从容器创建一个新的镜像-a 提交的镜像作者-c 使用Dockerfile指令来创建镜像-m 提交时的说明文字-p 在commit时，将容器暂停# cp [OPTIONS] CONTINER:SRC_PATH DEST_PATH|- 容器与主机之间的数据拷贝# cp [OPTIONS] SRC_PATH|- CONTINER:DEST_PATHdocker cp hostpath container:path-a 档案模式，复制所有uid/gid信息-L 保持源目标中的链接# diff [OPTIONS] CONTAINER 检查容器里文件结构的更改，是目前容器与镜像的文件比较，有三种追踪变化，A：创建了文件或目录，D：删除了文件或目录，C：修改了文件或目录 镜像仓库命令1234567891011121314151617# login [OPTIONS] [SERVER] 登陆到一个Docker镜像仓库，默认为Docker Hub# logout [OPTIONS] [SERVER] 登出-u 登陆名-p 密码# pull [OPTIONS] NAME[:TAG|@DIGEST]-a 拉取所有tagged镜像-diable-content-trust 忽略镜像的校验，默认开启# push [OPTIONS] NAME[:TAG]--diable-content-trust 忽略镜像的校验，默认开启docker push myjava:v1 # 上传本地镜像到镜像仓库中# search [OPTIONS] TERM--automated 只列出 automated build类型的镜像--no-trunc 显示完整的镜像描述-s 列出收藏数不小于指定值的镜像 本地镜像管理命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# images [OPTIONS] [REPOSITORY[:TAG]]-a 列出本地所有镜像（含中间层镜像，默认过滤中间层镜像）--digests 显示镜像的摘要-f 过滤--format 指定返回值的模板文件--no-trunc 显示完整的镜像信息-q 只显示镜像id# rmi [OPTIONS] IMAGE... 删除本地多个镜像-f 强制删除--no-prune 不移除该镜像的过程镜像，默认移除# tag [OPTIONS] IMAGE[:TAG] [REPOSITORY/][USERNAME/]NAME[:TAG] 标记本地镜像，将其归入某一仓库# build [OPTIONS] PATH | URL |- 使用DOckerfile创建镜像--add-host list 添加ip mapping到host--build-arg=[] 设置镜像创建时的变量--cpu-shares 设置cpu使用权重--cpu-period 限制cpu cfs周期--cpu-quota 限制cpu cfs配额--cpuset-cpus 指定使用的cpu id--cpuset-mems 指定使用的内存id--disable-content-trust 忽略校验，默认开启-f 指定要使用的Dockerfile路径--force-rm 设置镜像过程中删除中间容器--isolation 使用容器隔离技术--label=[] 设置镜像使用的元数据-m 设置内存最大值--memory-swap 设置Swap的最大值为内存+Swap，\"-1\"表示不限Swap--no-cache 创建镜像的过程不使用缓存--pull 尝试去更新镜像的新版本-q 安静模式，成功后只输入镜像id--rm 设置镜像成功后删除中间容器--shm-size 设置/dev/shm的大小，默认64MB--ulimit Ulimit配置# history [OPTIONS] IMAGE 查看指定镜像的创建历史-H 以可读的格式打印镜像大小和日期，默认为true--no-trunc 显示完成的提交记录-q 仅列出提交记录id # save [OPTIONS] IMAGE... 将指定镜像保持成tar归档文件-o 输出到的文件docker save -o myjava.tar gsj/myjava:v1# import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] 从归档文件中创建镜像-c 应用docker指令创建镜像-m 提交时的说明文字 info/version12# info 显示Docker系统信息，包括镜像和容器数# version 显示Docker版本信息","link":"/2019/01/10/docker安装与命令/"}],"tags":[{"name":"js","slug":"js","link":"/tags/js/"},{"name":"composer","slug":"composer","link":"/tags/composer/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"Gitlab","slug":"Gitlab","link":"/tags/Gitlab/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/技术/"}]}